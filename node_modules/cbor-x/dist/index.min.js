(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.CBOR={}))})(this,function(e){'use strict';var t=Math.log,s=Math.exp;function n(){try{let e=a();if(K&&(// bundled strings to skip past
x=K.postBundlePosition),x==V)w=null,C=null,T&&(T=null);else if(x>V){// over read
let e=new Error("Unexpected end of CBOR data");throw e.incomplete=!0,e}else if(!Q)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return e}catch(e){throw b(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer"))&&(e.incomplete=!0),e}}function a(){let e=C[x++],t=e>>5;if(e&=31,23<e)switch(e){case 24:e=C[x++];break;case 25:if(7==t)return c();e=N.getUint16(x),x+=2;break;case 26:if(7==t){let e=N.getFloat32(x);if(2<z.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let t=ue[(127&C[x])<<1|C[x+1]>>7];return x+=4,(t*e+(0<e?.5:-.5)>>0)/t}return x+=4,e}e=N.getUint32(x),x+=4;break;case 27:if(7==t){let e=N.getFloat64(x);return x+=8,e}if(1<t){if(0<N.getUint32(x))throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");e=N.getUint32(x+4)}else z.int64AsNumber?(e=4294967296*N.getUint32(x),e+=N.getUint32(x+4)):e=N.getBigUint64(x);x+=8;break;case 31:// indefinite length
switch(t){case 2:// byte string
case 3:// text string
throw new Error("Indefinite length not supported for byte or text strings");case 4:// array
let e,s=[],n=0;for(;(e=a())!=j;)s[n++]=e;return 4==t?s:3==t?s.join(""):Buffer.concat(s);case 5:// map
let r;if(z.mapsAsObjects){let e={};if(z.keyMap)for(;(r=a())!=j;)e[z.decodeKey(r)]=a();else for(;(r=a())!=j;)e[r]=a();return e}else{W&&(z.mapsAsObjects=!0,W=!1);let e=new Map;if(z.keyMap)for(;(r=a())!=j;)e.set(z.decodeKey(r),a());else for(;(r=a())!=j;)e.set(r,a());return e}case 7:return j;default:throw new Error("Invalid major type for indefinite length "+t);}default:throw new Error("Unknown token "+e);}switch(t){case 0:// positive int
return e;case 1:// negative int
return~e;case 2:// buffer
return u(e);case 3:// string
if(G>=x)return F.slice(x-q,(x+=e)-q);if(0==G&&140>V&&32>e){// for small blocks, avoiding the overhead of the extract call is helpful
let t=16>e?d(e):o(e);if(null!=t)return t}return ee(e);case 4:// array
let s=Array(e);//if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())	
//else 
for(let t=0;t<e;t++)s[t]=a();return s;case 5:// map
if(z.mapsAsObjects){let t={};if(z.keyMap)for(let s=0;s<e;s++)t[z.decodeKey(a())]=a();else for(let s=0;s<e;s++)t[a()]=a();return t}else{W&&(z.mapsAsObjects=!0,W=!1);let t=new Map;if(z.keyMap)for(let s=0;s<e;s++)t.set(z.decodeKey(a()),a());else for(let s=0;s<e;s++)t.set(a(),a());return t}case 6:// extension
if(e>=L){let t=w[8191&e];// check record structures first
// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
if(t)return t.read||(t.read=r(t)),t.read();if(65536>e){if(e==D)// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
return re(a());if(e==B){let e=h(),t=a();for(let s=2;s<e;s++)re([t++,a()]);return a()}if(e==L)return f();if(z.getShared&&(y(),t=w[8191&e],t))return t.read||(t.read=r(t)),t.read()}}let n=H[e];if(n)return n.handlesRead?n(a):n(a());else{let t=a();for(let s,n=0;n<J.length;n++)if(s=J[n](e,t),void 0!==s)return s;return new ne(t,e)}case 7:// fixed value
switch(e){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;// undefined
case 31:default:let t=(Y||p())[e];if(void 0!==t)return t;throw new Error("Unknown token "+e);}default:// negative int
if(isNaN(e)){let e=new Error("Unexpected end of CBOR data");throw e.incomplete=!0,e}throw new Error("Unknown CBOR token "+e);}}function r(e){function t(){// get the array size from the header
let e=C[x++];//let majorType = token >> 5
if(e&=31,23<e)switch(e){case 24:e=C[x++];break;case 25:e=N.getUint16(x),x+=2;break;case 26:e=N.getUint32(x),x+=4;break;default:throw new Error("Expected array header, but got "+C[x-1]);}// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
let t=this.compiledReader;// first look to see if we have the fast compiled function
for(;t;){// we have a fast compiled object literal reader
if(t.propertyCount===e)return t(a);// with the right length, so we use it
t=t.next}if(3<=this.slowReads++){// create a fast compiled reader
let s=this.length==e?this:this.slice(0,e);return t=z.keyMap?new Function("r","return {"+s.map(e=>z.decodeKey(e)).map(e=>Z.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}"):new Function("r","return {"+s.map(e=>Z.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}"),this.compiledReader&&(t.next=this.compiledReader),t.propertyCount=e,this.compiledReader=t,t(a)}let s={};if(z.keyMap)for(let t=0;t<e;t++)s[z.decodeKey(this[t])]=a();else for(let t=0;t<e;t++)s[this[t]]=a();return s}return e.slowReads=0,t}function i(e){let t;if(16>e&&(t=d(e)))return t;if(64<e&&A)return A.decode(C.subarray(x,x+=e));const s=x+e,n=[];for(t="";x<s;){const e=C[x++];if(0==(128&e))n.push(e);else if(192==(224&e)){// 2 bytes
const t=63&C[x++];n.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&C[x++],s=63&C[x++];n.push((31&e)<<12|t<<6|s)}else if(240==(248&e)){// 4 bytes
const t=63&C[x++],s=63&C[x++],a=63&C[x++];let r=(7&e)<<18|t<<12|s<<6|a;65535<r&&(r-=65536,n.push(55296|1023&r>>>10),r=56320|1023&r),n.push(r)}else n.push(e);4096<=n.length&&(t+=te.apply(String,n),n.length=0)}return 0<n.length&&(t+=te.apply(String,n)),t}function o(e){let t=x,s=Array(e);for(let n=0;n<e;n++){const e=C[x++];if(0<(128&e))return void(x=t);s[n]=e}return te.apply(String,s)}function d(t){if(4>t){if(!(2>t)){let e=C[x++],s=C[x++];if(0<(128&e)||0<(128&s))return void(x-=2);if(3>t)return te(e,s);let n=C[x++];return 0<(128&n)?void(x-=3):te(e,s,n)}if(0===t)return"";else{let e=C[x++];return 1<(128&e)?void(x-=1):te(e)}}else{let s=C[x++],a=C[x++],r=C[x++],u=C[x++];if(0<(128&s)||0<(128&a)||0<(128&r)||0<(128&u))return void(x-=4);if(6>t){if(4===t)return te(s,a,r,u);else{let t=C[x++];return 0<(128&t)?void(x-=5):te(s,a,r,u,t)}}else if(8>t){let n=C[x++],e=C[x++];if(0<(128&n)||0<(128&e))return void(x-=6);if(7>t)return te(s,a,r,u,n,e);let i=C[x++];return 0<(128&i)?void(x-=7):te(s,a,r,u,n,e,i)}else{let d=C[x++],e=C[x++],c=C[x++],p=C[x++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&p))return void(x-=8);if(10>t){if(8===t)return te(s,a,r,u,d,e,c,p);else{let t=C[x++];return 0<(128&t)?void(x-=9):te(s,a,r,u,d,e,c,p,t)}}else if(12>t){let n=C[x++],i=C[x++];if(0<(128&n)||0<(128&i))return void(x-=10);if(11>t)return te(s,a,r,u,d,e,c,p,n,i);let o=C[x++];return 0<(128&o)?void(x-=11):te(s,a,r,u,d,e,c,p,n,i,o)}else{let g=C[x++],i=C[x++],f=C[x++],h=C[x++];if(0<(128&g)||0<(128&i)||0<(128&f)||0<(128&h))return void(x-=12);if(!(14>t)){let l=C[x++],y=C[x++];if(0<(128&l)||0<(128&y))return void(x-=14);if(15>t)return te(s,a,r,u,d,e,c,p,g,i,f,h,l,y);let n=C[x++];return 0<(128&n)?void(x-=15):te(s,a,r,u,d,e,c,p,g,i,f,h,l,y,n)}if(12===t)return te(s,a,r,u,d,e,c,p,g,i,f,h);else{let t=C[x++];return 0<(128&t)?void(x-=13):te(s,a,r,u,d,e,c,p,g,i,f,h,t)}}}}}function u(e){return z.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(C,x,x+=e):C.subarray(x,x+=e)}function c(){let e,t=C[x++],n=C[x++],a=(t<<8)+n,r=31&a>>10,i=1023&a;return e=0==r?s(i,-24):31==r?0==i?1/0:NaN:s(i+1024,r-25),32768&a?-e:e}function l(e,t){return"string"==typeof e?e+t:e instanceof Array?e.concat(t):Object.assign({},e,t)}function p(){if(!Y)if(z.getShared)y();else throw new Error("No packed values available");return Y}function g(e,t){H[t]=t=>{if(!e)throw new Error("Could not find typed array for code "+typeCode);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new ae[e](Uint8Array.prototype.slice.call(t,0).buffer)}}function f(){let e=h(),t=x+a();for(let t,s=2;s<e;s++)// skip past bundles that were already read
// this will increment position, so must add to position afterwards
t=h(),x+=t;let s=x;return x=t,K=[i(h()),i(h())],K.position0=0,K.position1=0,K.postBundlePosition=x,x=s,a()}function h(){let e=31&C[x++];return 23<e&&(24===e?e=C[x++]:25===e?(e=N.getUint16(x),x+=2):26===e?(e=N.getUint32(x),x+=4):void 0),e}function y(){if(z.getShared){let e=m(()=>(C=null,z.getShared()))||{},t=e.structures||[];z.sharedVersion=e.version,Y=z.sharedValues=e.packedValues,!0===w?z.structures=w=t:w.splice.apply(w,[0,t.length].concat(t))}}function m(e){let t=V,s=x,n=q,a=G,r=F,i=T,o=K,d=new Uint8Array(C.slice(0,V)),u=w,c=z,l=Q,p=e();return V=t,x=s,q=n,G=a,F=r,T=i,K=o,C=d,Q=l,w=u,z=c,N=new DataView(C.buffer,C.byteOffset,C.byteLength),p}function b(){C=null,T=null,w=null}function k(e){H[e.tag]=e.decode}function O(e){24>e?_e[Ee++]=128|e:256>e?(_e[Ee++]=152,_e[Ee++]=e):65536>e?(_e[Ee++]=153,_e[Ee++]=e>>8,_e[Ee++]=255&e):(_e[Ee++]=154,Ie.setUint32(Ee,e),Ee+=4)}function R(e,t){switch(typeof e){case"string":if(3<e.length){if(-1<t.objectMap[e]||t.values.length>=t.maxValues)return;let s=t.get(e);if(s)2==++s.count&&t.values.push(e);else if(t.set(e,{count:1}),t.samplingPackedValues){let s=t.samplingPackedValues.get(e);s?s.count++:t.samplingPackedValues.set(e,{count:1})}}break;case"object":if(e)if(e instanceof Array)for(let s=0,n=e.length;s<n;s++)R(e[s],t);else{let n=!t.encoder.useRecords;for(var s in e)e.hasOwnProperty(s)&&(n&&R(s,t),R(e[s],t))}break;case"function":console.log(e);}}function M(e){return{tag:e,encode:function(e,t){let s=e.byteLength,n=e.byteOffset||0,a=e.buffer||e;t(ke?Buffer.from(a,n,s):new Uint8Array(a,n,s))}}}function S(e,t){let s=e.byteLength;24>s?_e[Ee++]=64+s:256>s?(_e[Ee++]=88,_e[Ee++]=s):65536>s?(_e[Ee++]=89,_e[Ee++]=s>>8,_e[Ee++]=255&s):(_e[Ee++]=90,Ie.setUint32(Ee,s),Ee+=4),Ee+s>=_e.length&&t(Ee+s),_e.set(e,Ee),Ee+=s}function _(e,t){// insert the ids that need to be referenced for structured clones
let s,n=2*t.length,a=e.length-n;t.sort((e,t)=>e.offset>t.offset?1:-1);for(let s,n=0;n<t.length;n++){s=t[n],s.id=n;for(let t of s.references)e[t++]=n>>8,e[t]=255&n}for(;s=t.pop();){let t=s.offset;e.copyWithin(t+n,t,a),n-=2;let r=t+n;// http://cbor.schmorp.de/value-sharing
e[r++]=216,e[r++]=28,a=t}return e}function I(e,t){Ie.setUint32(ve.position+e,Ee-ve.position-e+1);// the offset to bundle
let s=ve;ve=null,t(s[0]),t(s[1])}function U(e){if(e.Class){if(!e.encode)throw new Error("Extension has no encode function");be.unshift(e.Class),me.unshift(e)}k(e)}function*E(e,t){const s=new Ce(t);for(const n of e)yield s.encode(n)}async function*v(e,t){const s=new Ce(t);for await(const n of e)yield s.encode(n)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - Decoder options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */let A;try{A=new TextDecoder}catch(e){}let C,V,x=0;const B=57342,D=57343,L=57337,P=6,j={};let w,F,K,T,Y,N,W,z={},q=0,G=0,H=[],J=[],$={useRecords:!1,mapsAsObjects:!0},Q=!1;class X{constructor(e){if(e&&((e.keyMap||e._keyMap)&&!e.useRecords&&(e.useRecords=!1,e.mapsAsObjects=!0),!1===e.useRecords&&void 0===e.mapsAsObjects&&(e.mapsAsObjects=!0),e.getStructures&&(e.getShared=e.getStructures),e.getShared&&!e.structures&&((e.structures=[]).uninitialized=!0),e.keyMap))// this is what we use to denote an uninitialized structures
{this.mapKey=new Map;for(let[t,s]of Object.entries(e.keyMap))this.mapKey.set(s,t)}Object.assign(this,e)}/*
		decodeKey(key) {
			return this.keyMap
				? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
				: key
		}
		*/decodeKey(e){return this.keyMap?this.mapKey.get(e)||e:e}encodeKey(e){return this.keyMap&&this.keyMap.hasOwnProperty(e)?this.keyMap[e]:e}encodeKeys(e){if(!this._keyMap)return e;let t=new Map;for(let[s,n]of Object.entries(e))t.set(this._keyMap.hasOwnProperty(s)?this._keyMap[s]:s,n);return t}decodeKeys(e){if(!this._keyMap||"Map"!=e.constructor.name)return e;if(!this._mapKey){this._mapKey=new Map;for(let[e,t]of Object.entries(this._keyMap))this._mapKey.set(t,e)}let t={};//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)
return e.forEach((e,s)=>t[this._mapKey.has(s)?this._mapKey.get(s):s]=e),t}mapDecode(e){let t=this.decode(e);if(this._keyMap)//Experiemntal support for Optimised KeyMap  decoding 
switch(t.constructor.name){case"Array":return t.map(e=>this.decodeKeys(e));//case 'Map': return this.decodeKeys(res)
}return t}decode(e,t){if(C)// re-entrant execution, save the state and restore it after we do this decode
return m(()=>(b(),this?this.decode(e,t):X.prototype.decode.call($,e,t)));V=-1<t?t:e.length,x=0,G=0,F=null,K=null,C=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{N=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(C=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof X){if(z=this,Y=this.sharedValues&&(this.pack?Array(this.maxPrivatePackedValues||16).concat(this.sharedValues):this.sharedValues),this.structures)return w=this.structures,n();(!w||0<w.length)&&(w=[])}else z=$,(!w||0<w.length)&&(w=[]),Y=null;return n()}decodeMultiple(e,t){let s,a=0;try{let r=e.length;Q=!0;let i=this?this.decode(e,r):ce.decode(e,r);if(t){if(!1===t(i))return;for(;x<r;)if(a=x,!1===t(n()))return}else{for(s=[i];x<r;)a=x,s.push(n());return s}}catch(e){throw e.lastPosition=a,e.values=s,e}finally{Q=!1,b()}}}const Z=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;let ee=i,te=String.fromCharCode,se=Array(4096);class ne{constructor(e,t){this.value=e,this.tag=t}}let ae="object"==typeof self?self:global;H[0]=e=>new Date(e),H[1]=e=>new Date(1e3*e),H[2]=e=>{// bigint extension
let t=BigInt(0);for(let s=0,n=e.byteLength;s<n;s++)t=BigInt(e[s])+t<<BigInt(8);return t},H[3]=e=>BigInt(-1)-H[2](e),H[4]=e=>+(e[1]+"e"+e[0]),H[5]=e=>e[1]*s(e[0]*t(2));// the registration of the record definition extension
const re=e=>{let t=e[0]-57344,s=e[1],n=w[t];n&&n.isShared&&((w.restoreStructures||(w.restoreStructures=[]))[t]=n),w[t]=s,s.read=r(s);let a={};if(z.keyMap)for(let t,n=2,r=e.length;n<r;n++)t=z.decodeKey(s[n-2]),a[t]=e[n];else for(let t,n=2,r=e.length;n<r;n++)t=s[n-2],a[t]=e[n];return a};H[105]=re,H[14]=e=>K?K[0].slice(K.position0,K.position0+=e):new ne(e,14),H[15]=e=>K?K[1].slice(K.position1,K.position1+=e):new ne(e,15),H[27]=e=>(ae[e[0]]||Error)(e[1],e[2]);const ie=e=>{if(132!=C[x++])throw new Error("Packed values structure must be followed by a 4 element array");let t=e();// packed values
return Y=Y?t.concat(Y.slice(t.length)):t,Y.prefixes=e(),Y.suffixes=e(),e();// read the rump
};ie.handlesRead=!0,H[51]=ie,H[P]=e=>{// packed reference
if(!Y)if(z.getShared)y();else return new ne(e,P);if("number"==typeof e)return Y[16+(0<=e?2*e:-2*e-1)];throw new Error("No support for non-integer packed references yet")},H[25]=e=>stringRefs[e],H[256]=e=>{stringRefs=[];try{return e()}finally{stringRefs=null}},H[256].handlesRead=!0,H[28]=e=>{T||(T=new Map,T.id=0);let t,s=T.id++,n=C[x];t=4==n>>5?[]:{};let a={target:t};// a placeholder object
T.set(s,a);let r=e();// read the next value as the target object to id
return a.used?Object.assign(t,r):(a.target=r,r);// no cycle, can just use the returned read object
},H[28].handlesRead=!0,H[29]=e=>{// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
let t=T.get(e);return t.used=!0,t.target},H[258]=e=>new Set(e),(H[259]=e=>(z.mapsAsObjects&&(z.mapsAsObjects=!1,W=!0),e())).handlesRead=!0;J.push((e,t)=>225<=e&&255>=e?l(p().prefixes[e-224],t):28704<=e&&32767>=e?l(p().prefixes[e-28672],t):1879052288<=e&&2147483647>=e?l(p().prefixes[e-1879048192],t):216<=e&&223>=e?l(t,p().suffixes[e-216]):27647<=e&&28671>=e?l(t,p().suffixes[e-27639]):1811940352<=e&&1879048191>=e?l(t,p().suffixes[e-1811939328]):e==1399353956?{packedValues:Y,structures:w.slice(0),version:t}:55799==e?t:void 0);const oe=["Uint8","Uint8Clamped","Uint16","Uint32","BigUint64","Int8","Int16","Int32","BigInt64","Float32","Float64"].map(e=>e+"Array"),de=[64,68,69,70,71,72,77,78,79,81,82];for(let t=0;t<oe.length;t++)g(oe[t],de[t]);const ue=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let t=0;256>t;t++)ue[t]=+("1e"+Math.floor(45.15-.30103*t));let ce=new X({useRecords:!1});const le=ce.decode,pe=ce.decodeMultiple,ge={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let fe,he=new Float32Array(1),ye=new Uint8Array(he.buffer,0,4);try{fe=new TextEncoder}catch(e){}let me,be;const ke="undefined"!=typeof Buffer,Oe=ke?Buffer.allocUnsafeSlow:Uint8Array,Re=ke?Buffer:Uint8Array,Me=256,Se=ke?4294967296:2144337920;let _e,Ie,Ue,Ee=0,ve=null;const Ae=Symbol("record-id");class Ce extends X{constructor(e){super(e),this.offset=0;let t,s,n,a,r;e=e||{};let i=Re.prototype.utf8Write?function(e,t,s){return _e.utf8Write(e,t,s)}:!!(fe&&fe.encodeInto)&&function(e,t){return fe.encodeInto(e,_e.subarray(t)).written},o=this,d=e.structures||e.saveStructures,u=e.maxSharedStructures;if(null==u&&(u=d?128:0),8190<u)throw new Error("Maximum maxSharedStructure is 8190");let c=e.sequential;c&&(u=0),this.structures||(this.structures=[]),this.saveStructures&&(this.saveShared=this.saveStructures);let l,p,g,f=e.sharedValues;if(f){g=Object.create(null);for(let e=0,t=f.length;e<t;e++)g[f[e]]=e}let h=[],y=0,m=0;this.mapEncode=function(e,t){// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)
if(this._keyMap&&!this._mapped)//console.log('encoding ', value)
switch(e.constructor.name){case"Array":e=e.map(e=>this.encodeKeys(e));//case 'Map': 
//	value = this.encodeKeys(value)
//	break
}//this._mapped = true
return this.encode(e,t)},this.encode=function(i,d){if(_e||(_e=new Oe(8192),Ie=new DataView(_e.buffer,0,8192),Ee=0),Ue=_e.length-10,2048>Ue-Ee?(_e=new Oe(_e.length),Ie=new DataView(_e.buffer,0,_e.length),Ue=_e.length-10,Ee=0):d===we&&(Ee=2147483640&Ee+7),t=Ee,o.useSelfDescribedHeader&&(Ie.setUint32(Ee,3654940416),Ee+=3),r=o.structuredClone?new Map:null,o.bundleStrings&&"string"!=typeof i?(ve=[],ve.size=1/0):ve=null,s=o.structures,s){if(s.uninitialized){let e=o.getShared()||{};o.structures=s=e.structures||[],o.sharedVersion=e.version;let t=o.sharedValues=e.packedValues;if(t){g={};for(let e=0,s=t.length;e<s;e++)g[t[e]]=e}}let e=s.length;if(e>u&&!c&&(e=u),!s.transitions){s.transitions=Object.create(null);for(let t,n=0;n<e;n++){//console.log('shared struct keys:', keys)
if(t=s[n],!t)continue;let e,a=s.transitions;for(let s=0,r=t.length;s<r;s++){void 0===a[Ae]&&(a[Ae]=n);let r=t[s];e=a[r],e||(e=a[r]=Object.create(null)),a=e}a[Ae]=1048576|n}}c||(s.nextId=e)}if(n&&(n=!1),a=s||[],p=g,e.pack){let t=new Map;if(t.values=[],t.encoder=o,t.maxValues=e.maxPrivatePackedValues||(g?16:1/0),t.objectMap=g||!1,t.samplingPackedValues=l,R(i,t),0<t.values.length){_e[Ee++]=216,_e[Ee++]=51,O(4);let e=t.values;b(e),O(0),O(0),p=Object.create(g||null);for(let t=0,s=e.length;t<s;t++)p[e[t]]=t}}try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(b(i),ve&&I(t,b),o.offset=Ee,r&&r.idsToInsert){Ee+=2*r.idsToInsert.length,Ee>Ue&&M(Ee),o.offset=Ee;let e=_(_e.subarray(t,Ee),r.idsToInsert);return r=null,e}return d&we?(_e.start=t,_e.end=Ee,_e):_e.subarray(t,Ee);// position can change if we call encode again in saveShared, so we get the buffer now
}finally{if(s)if(10>m&&m++,s.length>u&&(s.length=u),1e4<y)s.transitions=null,m=0,y=0,0<h.length&&(h=[]);else if(0<h.length&&!c){for(let e=0,t=h.length;e<t;e++)h[e][Ae]=void 0;h=[]}if(n&&o.saveShared){o.structures.length>u&&(o.structures=o.structures.slice(0,u));// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let e=_e.subarray(t,Ee);return!1===o.updateSharedData()?o.encode(i):e;// re-encode if it fails
}d&Fe&&(Ee=t)}},this.findCommonStringsToPack=()=>(l=new Map,g||(g=Object.create(null)),e=>{let t=e&&e.threshold||4,s=this.pack?e.maxPrivatePackedValues||16:0;f||(f=this.sharedValues=[]);for(let[a,r]of l)r.count>t&&(g[a]=s++,f.push(a),n=!0);for(;this.saveShared&&!1===this.updateSharedData(););l=null});const b=s=>{Ee>Ue&&(_e=M(Ee));var n,a=typeof s;if("string"==a){if(p){let t=p[s];if(0<=t)return void(16>t?_e[Ee++]=t+224:(_e[Ee++]=198,1&t?b(15-t>>1):b(t-16>>1)));/*						} else if (packedStatus.serializationId != serializationId) {
								packedStatus.serializationId = serializationId
								packedStatus.count = 1
								if (options.sharedPack) {
									let sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1
									if (shareCount > (options.sharedPack.threshold || 5)) {
										let sharedPosition = packedStatus.position = packedStatus.nextSharedPosition
										hasSharedUpdate = true
										if (sharedPosition < 16)
											target[position++] = sharedPosition + 0xc0

									}
								}
							} // else any in-doc incrementation?*/if(l&&!e.pack){let e=l.get(s);e?e.count++:l.set(s,{count:1})}}let a=s.length;if(ve&&4<=a&&1024>a){if((ve.size+=a)>61440){let e,s=(ve[0]?3*ve[0].length+ve[1].length:0)+10;Ee+s>Ue&&(_e=M(Ee+s)),_e[Ee++]=217,_e[Ee++]=223,_e[Ee++]=249,_e[Ee++]=ve.position?132:130,_e[Ee++]=26,e=Ee-t,Ee+=4,ve.position&&I(t,b),ve=["",""],ve.size=0,ve.position=e}let e=/[\u0080-\uFFFF]/.test(s);return ve[e?0:1]+=s,_e[Ee++]=e?206:207,void b(a)}let r=32>a?1:256>a?2:65536>a?3:5;// first we estimate the header size, so we can write to the correct location
let o=3*a;if(Ee+o>Ue&&(_e=M(Ee+o)),64>a||!i){let e,t,i,o=Ee+r;for(e=0;e<a;e++)t=s.charCodeAt(e),128>t?_e[o++]=t:2048>t?(_e[o++]=192|t>>6,_e[o++]=128|63&t):55296==(64512&t)&&56320==(64512&(i=s.charCodeAt(e+1)))?(t=65536+((1023&t)<<10)+(1023&i),e++,_e[o++]=240|t>>18,_e[o++]=128|63&t>>12,_e[o++]=128|63&t>>6,_e[o++]=128|63&t):(_e[o++]=224|t>>12,_e[o++]=128|63&t>>6,_e[o++]=128|63&t);n=o-Ee-r}else n=i(s,Ee+r,o);24>n?_e[Ee++]=96|n:256>n?(2>r&&_e.copyWithin(Ee+2,Ee+1,Ee+1+n),_e[Ee++]=120,_e[Ee++]=n):65536>n?(3>r&&_e.copyWithin(Ee+3,Ee+2,Ee+2+n),_e[Ee++]=121,_e[Ee++]=n>>8,_e[Ee++]=255&n):(5>r&&_e.copyWithin(Ee+5,Ee+3,Ee+3+n),_e[Ee++]=122,Ie.setUint32(Ee,n),Ee+=4),Ee+=n}else if("number"===a){if(s>>>0===s)24>s?_e[Ee++]=s:256>s?(_e[Ee++]=24,_e[Ee++]=s):65536>s?(_e[Ee++]=25,_e[Ee++]=s>>8,_e[Ee++]=255&s):(_e[Ee++]=26,Ie.setUint32(Ee,s),Ee+=4);else if(s>>0===s)-24<=s?_e[Ee++]=31-s:-256<=s?(_e[Ee++]=56,_e[Ee++]=~s):-65536<=s?(_e[Ee++]=57,Ie.setUint16(Ee,~s),Ee+=2):(_e[Ee++]=58,Ie.setUint32(Ee,~s),Ee+=4);else{let e;if(0<(e=this.useFloat32)&&4294967296>s&&-2147483648<=s){_e[Ee++]=250,Ie.setFloat32(Ee,s);let t;if(4>e||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(t=s*ue[(127&_e[Ee])<<1|_e[Ee+1]>>7])>>0===t)return void(Ee+=4);// move back into position for writing a double
Ee--}_e[Ee++]=251,Ie.setFloat64(Ee,s),Ee+=8}}else if("object"===a){if(!s)_e[Ee++]=246;else{if(r){let e=r.get(s);if(e){// 16-bit uint
if(_e[Ee++]=216,_e[Ee++]=29,_e[Ee++]=25,!e.references){let t=r.idsToInsert||(r.idsToInsert=[]);e.references=[],t.push(e)}// TODO: also support 32-bit
return e.references.push(Ee-t),void(Ee+=2)}r.set(s,{offset:Ee-t})}let e=s.constructor;if(e===Object)k(s,!0);else if(e===Array){n=s.length,24>n?_e[Ee++]=128|n:O(n);for(let e=0;e<n;e++)b(s[e])}else if(e!==Map){for(let e,t=0,n=me.length;t<n;t++)if(e=be[t],s instanceof e){let e=me[t],n=e.tag||e.getTag&&e.getTag(s);return 24>n?_e[Ee++]=192|n:256>n?(_e[Ee++]=216,_e[Ee++]=n):65536>n?(_e[Ee++]=217,_e[Ee++]=n>>8,_e[Ee++]=255&n):-1<n&&(_e[Ee++]=218,Ie.setUint32(Ee,n),Ee+=4),void e.encode.call(this,s,b,M)}if(s[Symbol.iterator]){_e[Ee++]=159;// indefinite length array
for(let e of s)b(e);// stop-code
return void(_e[Ee++]=255)}// no extension found, write as object
k(s,!s.hasOwnProperty)}else if((this.mapsAsObjects?!1!==this.useTag259ForMaps:this.useTag259ForMaps)&&(_e[Ee++]=217,_e[Ee++]=1,_e[Ee++]=3),n=s.size,24>n?_e[Ee++]=160|n:256>n?(_e[Ee++]=184,_e[Ee++]=n):65536>n?(_e[Ee++]=185,_e[Ee++]=n>>8,_e[Ee++]=255&n):(_e[Ee++]=186,Ie.setUint32(Ee,n),Ee+=4),o.keyMap)for(let[e,t]of s)b(o.encodeKey(e)),b(t);else for(let[e,t]of s)b(e),b(t)}}else if("boolean"===a)_e[Ee++]=s?245:244;else if("bigint"===a){if(s<BigInt(1)<<BigInt(64)&&0<=s)_e[Ee++]=27,Ie.setBigUint64(Ee,s);else if(s>-(BigInt(1)<<BigInt(64))&&0>s)_e[Ee++]=59,Ie.setBigUint64(Ee,-s-BigInt(1));else// overflow
if(this.largeBigIntToFloat)_e[Ee++]=251,Ie.setFloat64(Ee,+s);else throw new RangeError(s+" was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");Ee+=8}else if("undefined"===a)_e[Ee++]=247;else throw new Error("Unknown type: "+a)},k=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),s=Object.values(e),n=t.length;if(24>n?_e[Ee++]=160|n:256>n?(_e[Ee++]=184,_e[Ee++]=n):65536>n?(_e[Ee++]=185,_e[Ee++]=n>>8,_e[Ee++]=255&n):(_e[Ee++]=186,Ie.setUint32(Ee,n),Ee+=4),o.keyMap)for(let e=0;e<n;e++)b(encodeKey(t[e])),b(s[e]);else for(let e=0;e<n;e++)b(t[e]),b(s[e])}:(e,s)=>{_e[Ee++]=185;// always use map 16, so we can preallocate and set the length afterwards
let n=Ee-t;Ee+=2;let a=0;if(o.keyMap)for(let t in e)(s||e.hasOwnProperty(t))&&(b(o.encodeKey(t)),b(e[t]),a++);else for(let t in e)(s||e.hasOwnProperty(t))&&(b(t),b(e[t]),a++);_e[n++ +t]=a>>8,_e[n+t]=255&a}:(e,t)=>{let s,r,o,d=a.transitions||(a.transitions=Object.create(null)),c=0,l=0;if(this.keyMap){o=Object.keys(e).map(e=>this.encodeKey(e)),l=o.length;for(let e,t=0;t<l;t++)e=o[t],s=d[e],s||(s=d[e]=Object.create(null),c++),d=s}else for(let n in e)(t||e.hasOwnProperty(n))&&(s=d[n],s||(1048576&d[Ae]&&(r=65535&d[Ae]),s=d[n]=Object.create(null),c++),d=s,l++);let p=d[Ae];if(void 0!==p)p&=65535,_e[Ee++]=217,_e[Ee++]=224|p>>8,_e[Ee++]=255&p;else if(o||(o=d.__keys__||(d.__keys__=Object.keys(e))),void 0===r?(p=a.nextId++,!p&&(p=0,a.nextId=1),p>=Me&&(a.nextId=(p=u)+1)):p=r,a[p]=o,p<u){_e[Ee++]=217,_e[Ee++]=224|p>>8,_e[Ee++]=255&p,d=a.transitions;for(let e=0;e<l;e++)(void 0===d[Ae]||1048576&d[Ae])&&(d[Ae]=p),d=d[o[e]];d[Ae]=1048576|p,n=!0}else{d[Ae]=p,Ie.setUint32(Ee,3655335680),Ee+=3,c&&(y+=m*c),h.length>=Me-u&&(h.shift()[Ae]=void 0),h.push(d),O(l+2),b(57344+p),b(o);for(let t of Object.values(e))b(t);return}for(let s in 24>l?_e[Ee++]=128|l:O(l),e)(t||e.hasOwnProperty(s))&&b(e[s])},M=e=>{var s=Math.min,n=Math.round,a=Math.max;let r;if(16777216<e){// special handling for really large buffers
if(e-t>Se)throw new Error("Encoded buffer would be larger than maximum buffer size");r=s(Se,4096*n(a((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
r=(a(e-t<<2,_e.length-1)>>12)+1<<12;let i=new Oe(r);return Ie=new DataView(i.buffer,0,r),_e.copy?_e.copy(i,0,t,e):i.set(_e.slice(t,e)),Ee-=t,t=0,Ue=i.length-10,_e=i}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
_e=e,Ie=new DataView(_e.buffer,_e.byteOffset,_e.byteLength),Ee=0}clearSharedData(){this.structures&&(this.structures=[]),this.sharedValues&&(this.sharedValues=void 0)}updateSharedData(){let e=this.sharedVersion||0;this.sharedVersion=e+1;let t=this.structures.slice(0),s=new Ve(t,this.sharedValues,this.sharedVersion),n=this.saveShared(s,t=>(t&&t.version||0)==e);// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data
return!1===n?(s=this.getShared()||{},this.structures=s.structures||[],this.sharedValues=s.packedValues,this.sharedVersion=s.version,this.structures.nextId=this.structures.length):t.forEach((e,t)=>this.structures[t]=e),n}}class Ve{constructor(e,t,s){this.structures=e,this.packedValues=t,this.version=s}}be=[Date,Set,Error,RegExp,ne,ArrayBuffer,Re,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,"undefined"==typeof BigUint64Array?function(){}:BigUint64Array,Int8Array,Int16Array,Int32Array,"undefined"==typeof BigInt64Array?function(){}:BigInt64Array,Float32Array,Float64Array,Ve],me=[{tag:1,encode(e){let t=e.getTime()/1e3;(this.useTimestamp32||0===e.getMilliseconds())&&0<=t&&4294967296>t?(_e[Ee++]=26,Ie.setUint32(Ee,t),Ee+=4):(_e[Ee++]=251,Ie.setFloat64(Ee,t),Ee+=8)}},{tag:258,// https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
encode(e,t){let s=Array.from(e);t(s)}},{tag:27,// http://cbor.schmorp.de/generic-object
encode(e,t){t([e.name,e.message])}},{tag:27,// http://cbor.schmorp.de/generic-object
encode(e,t){t(["RegExp",e.source,e.flags])}},{getTag(e){return e.tag},encode(e,t){t(e.value)}},{encode(e,t,s){S(e,s)}},{encode(e,t,s){S(e,s)}},M(64),M(68),M(69),M(70),M(71),M(72),M(77),M(78),M(79),M(81),M(82),{encode(e,t){// write SharedData
let s=e.packedValues||[],n=e.structures||[];if(0<s.values.length){_e[Ee++]=216,_e[Ee++]=51,O(4);let e=s.values;t(e),O(0),O(0),packedObjectMap=Object.create(sharedPackedObjectMap||null);for(let t=0,s=e.length;t<s;t++)packedObjectMap[e[t]]=t}if(n){Ie.setUint32(Ee,3655335424),Ee+=3;let s=n.slice(0);s.unshift(57344),s.push(new ne(e.version,1399353956)),t(s)}else t(new ne(e.version,1399353956))}}];let xe=new Ce({useRecords:!1});const Be=xe.encode,{NEVER:De,ALWAYS:Le,DECIMAL_ROUND:Pe,DECIMAL_FIT:je}=ge,we=512,Fe=1024;e.ALWAYS=Le,e.DECIMAL_FIT=je,e.DECIMAL_ROUND=Pe,e.Decoder=X,e.Encoder=Ce,e.FLOAT32_OPTIONS=ge,e.NEVER=De,e.REUSE_BUFFER_MODE=we,e.Tag=ne,e.addExtension=U,e.clearSource=b,e.decode=le,e.decodeIter=function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const s=new X(t);let n;const a=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
n&&(e=Buffer.concat([n,e]),n=void 0);try{t=s.decodeMultiple(e)}catch(s){if(s.incomplete)n=e.slice(s.lastPosition),t=s.values;else throw s}return t};if("function"==typeof e[Symbol.iterator])return function*(){for(const t of e)yield*a(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*a(t)}():void 0},e.decodeMultiple=pe,e.encode=Be,e.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - cbor-x Encoder options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return E(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return v(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.roundFloat32=function(e){he[0]=e;let t=ue[(127&ye[3])<<1|ye[2]>>7];return(t*e+(0<e?.5:-.5)>>0)/t},Object.defineProperty(e,"__esModule",{value:!0})});
